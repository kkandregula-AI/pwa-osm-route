<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
<title>DriveNav</title>

<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
<meta name="apple-mobile-web-app-title" content="DriveNav"/>
<meta name="theme-color" content="#111827"/>

<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" href="data:,">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{
    --bg:#f6f7fb; --card:#fff; --ink:#0f172a; --muted:#64748b;
    --brand:#111827; --line:#e5e7eb; --blue:#2563eb; --red:#e11d48;
  }
  body{ margin:0; font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--ink); padding-bottom:env(safe-area-inset-bottom); }
  header{ background:var(--brand); color:#fff; padding:14px 14px 12px; font-weight:900; letter-spacing:.2px; }
  header .sub{ font-weight:600; font-size:12px; opacity:.75; margin-top:4px; }
  .sheet{ padding:12px; display:grid; gap:10px; }
  .card{ background:var(--card); border:1px solid var(--line); border-radius:16px; padding:12px; box-shadow:0 6px 20px rgba(15,23,42,.06); }
  .row{ display:flex; gap:8px; flex-wrap:wrap; }
  .field{ display:grid; gap:6px; flex:1; min-width:220px; position:relative; }
  label{ font-size:12px; color:var(--muted); font-weight:700; }
  input{ width:100%; box-sizing:border-box; padding:12px 12px; border-radius:14px; border:1px solid var(--line); font-size:15px; outline:none; background:#fff; }
  input:focus{ border-color:#cbd5e1; box-shadow:0 0 0 4px rgba(37,99,235,.08); }
  .hint{ font-size:12px; color:var(--muted); margin-top:2px; }
  .btn{ padding:12px 14px; border:none; border-radius:14px; font-weight:900; background:var(--brand); color:#fff; cursor:pointer; flex:1; min-width:160px; }
  .btn.secondary{ background:#334155; }
  .btn.ghost{ background:#eef2ff; color:var(--brand); }
  .btn:disabled{ opacity:.45; cursor:not-allowed; }
  #map{ height:55vh; border-top:1px solid var(--line); }

  .pillRow{ display:flex; gap:8px; flex-wrap:wrap; }
  .pill{ background:#f1f5f9; padding:7px 10px; border-radius:999px; font-size:13px; font-weight:800; color:#0f172a; }
  .pill.ok{ background:#ecfeff; color:#155e75; }
  .pill.bad{ background:#fff1f2; color:#9f1239; }

  /* Suggestions */
  .suggest{ position:absolute; top:74px; left:0; right:0; background:#fff; border:1px solid var(--line); border-radius:14px; overflow:hidden; box-shadow:0 18px 30px rgba(15,23,42,.12); z-index:999; }
  .sItem{ padding:10px 12px; border-bottom:1px solid #f1f5f9; font-size:13px; cursor:pointer; }
  .sItem:last-child{ border-bottom:none; }
  .sItem:hover{ background:#f8fafc; }
  .sTitle{ font-weight:800; }
  .sSub{ color:var(--muted); font-size:12px; margin-top:2px; }

  /* Turn-by-turn panel */
  .turnCard{
    background:#0b1220;
    color:#fff;
    border-radius:16px;
    padding:12px;
    border:1px solid rgba(255,255,255,.08);
    box-shadow:0 10px 30px rgba(2,6,23,.25);
    display:none;
  }
  .turnTop{ display:flex; justify-content:space-between; gap:10px; align-items:flex-start; }
  .turnTitle{ font-size:12px; opacity:.8; font-weight:800; letter-spacing:.4px; }
  .turnMain{ font-size:16px; font-weight:900; line-height:1.2; margin-top:4px; }
  .turnMeta{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
  .chip{ background:rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; font-weight:800; font-size:13px; }

  .stepsWrap{ margin-top:10px; background:rgba(255,255,255,.08); border-radius:14px; overflow:hidden; }
  .stepsHead{ display:flex; justify-content:space-between; align-items:center; padding:10px 12px; cursor:pointer; }
  .stepsHead span{ font-weight:900; font-size:13px; }
  .stepsList{ display:none; border-top:1px solid rgba(255,255,255,.12); }
  .stepRow{ padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.08); }
  .stepRow:last-child{ border-bottom:none; }
  .stepLine1{ font-weight:900; font-size:13px; }
  .stepLine2{ opacity:.8; font-size:12px; margin-top:2px; }
</style>
</head>

<body>
<header>
  DriveNav
  <div class="sub">OSM + OSRM • Autocomplete • Turn-by-turn</div>
</header>

<div class="sheet">
  <div class="card">
    <div class="row">
      <div class="field" id="startField">
        <label>Start</label>
        <input id="startInput" placeholder="Current location (default)" autocomplete="off"/>
        <div class="hint">Leave empty to use GPS.</div>
        <div id="startSug" class="suggest" style="display:none"></div>
      </div>

      <div class="field" id="destField">
        <label>Destination</label>
        <input id="destInput" placeholder="Type destination…" autocomplete="off"/>
        <div class="hint" id="destHint">Type 3+ chars to see suggestions.</div>
        <div id="destSug" class="suggest" style="display:none"></div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button class="btn ghost" id="btnUseGPS">Use GPS Start</button>
      <button class="btn" id="btnRoute">Show Route</button>
      <button class="btn secondary" id="btnNav" disabled>Start Navigation</button>
      <button class="btn ghost" id="btnClear">Clear</button>
    </div>

    <div class="pillRow" style="margin-top:10px">
      <div class="pill" id="pillDist">Distance: —</div>
      <div class="pill" id="pillEta">ETA: —</div>
      <div class="pill ok" id="pillState">Ready</div>
    </div>
  </div>

  <!-- ✅ Turn-by-turn panel -->
  <div class="turnCard" id="turnCard">
    <div class="turnTop">
      <div>
        <div class="turnTitle">NEXT</div>
        <div class="turnMain" id="turnMain">—</div>
      </div>
      <div class="turnTitle" id="turnRight"> </div>
    </div>

    <div class="turnMeta">
      <div class="chip" id="turnDist">In —</div>
      <div class="chip" id="turnRoad">Road: —</div>
    </div>

    <div class="stepsWrap">
      <div class="stepsHead" id="stepsToggle">
        <span>Upcoming steps</span>
        <span id="stepsChevron">▾</span>
      </div>
      <div class="stepsList" id="stepsList"></div>
    </div>
  </div>
</div>

<div id="map"></div>

<script>
  const NOMINATIM = "https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=6&q=";
  const OSRM = "https://router.project-osrm.org/route/v1/driving/";

  // UI
  const startInput = document.getElementById("startInput");
  const destInput  = document.getElementById("destInput");
  const startSug   = document.getElementById("startSug");
  const destSug    = document.getElementById("destSug");
  const destHint   = document.getElementById("destHint");

  const btnUseGPS  = document.getElementById("btnUseGPS");
  const btnRoute   = document.getElementById("btnRoute");
  const btnNav     = document.getElementById("btnNav");
  const btnClear   = document.getElementById("btnClear");

  const pillDist   = document.getElementById("pillDist");
  const pillEta    = document.getElementById("pillEta");
  const pillState  = document.getElementById("pillState");

  const turnCard   = document.getElementById("turnCard");
  const turnMain   = document.getElementById("turnMain");
  const turnDist   = document.getElementById("turnDist");
  const turnRoad   = document.getElementById("turnRoad");
  const stepsToggle= document.getElementById("stepsToggle");
  const stepsChevron = document.getElementById("stepsChevron");
  const stepsList  = document.getElementById("stepsList");

  // Map
  const map = L.map("map", { zoomControl: true }).setView([19.076, 72.8777], 12);
  L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors",
  }).addTo(map);

  // State
  let startLL = null;     // [lat, lon]
  let destLL  = null;

  let startMarker = null;
  let destMarker  = null;
  let userMarker  = null;
  let routeLine   = null;

  let routeCoords = [];       // [[lat,lon],...]
  let routeDurationSec = 0;
  let routeDistanceM = 0;

  // Turn-by-turn
  let steps = [];             // simplified step objects
  let cumStepDist = [];       // cumulative distance array for step mapping

  let watchId = null;
  let upcomingOpen = false;

  function setPillState(text, kind="ok") {
    pillState.textContent = text;
    pillState.className = "pill " + (kind === "bad" ? "bad" : "ok");
  }

  function fmtDist(m){
    if (!Number.isFinite(m)) return "—";
    if (m < 1000) return Math.round(m) + " m";
    return (m/1000).toFixed(1) + " km";
  }

  function fmtETA(sec){
    if (!Number.isFinite(sec)) return "—";
    const min = Math.max(1, Math.round(sec/60));
    return min + " min";
  }

  function setMarker(existing, latlng, label, color) {
    if (existing) map.removeLayer(existing);
    if (!latlng) return null;

    const icon = L.divIcon({
      className: "m",
      html: `<div style="width:14px;height:14px;border-radius:999px;background:${color};border:2px solid #fff;box-shadow:0 2px 10px rgba(0,0,0,.25)"></div>`,
      iconSize: [14,14],
      iconAnchor: [7,7]
    });

    const m = L.marker(latlng, { icon }).addTo(map);
    if (label) m.bindPopup(label);
    return m;
  }

  function haversineMeters(a, b) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(b[0] - a[0]);
    const dLon = toRad(b[1] - a[1]);
    const lat1 = toRad(a[0]);
    const lat2 = toRad(b[0]);
    const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function nearestIndex(point, route) {
    let bestI = 0, bestD = Infinity;
    for (let i=0; i<route.length; i++) {
      const d = haversineMeters(point, route[i]);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return { index: bestI, distance: bestD };
  }

  function remainingDistance(route, fromIndex) {
    let sum = 0;
    for (let i = fromIndex; i < route.length - 1; i++) {
      sum += haversineMeters(route[i], route[i + 1]);
    }
    return sum;
  }

  function routeTotalDistance(route){
    let sum = 0;
    for (let i=0;i<route.length-1;i++) sum += haversineMeters(route[i], route[i+1]);
    return sum;
  }

  function debounce(fn, wait) {
    let t = null;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
  }

  async function geocode(q) {
    const res = await fetch(NOMINATIM + encodeURIComponent(q), { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error("Geocode HTTP " + res.status);
    return await res.json();
  }

  async function getCurrentPosition() {
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve([pos.coords.latitude, pos.coords.longitude]),
        (err) => reject(err),
        { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 }
      );
    });
  }

  function showSuggestions(el, items, onPick) {
    el.innerHTML = "";
    if (!items.length) { el.style.display = "none"; return; }
    items.forEach(it => {
      const div = document.createElement("div");
      div.className = "sItem";
      const title = (it.display_name || "").split(",").slice(0,2).join(", ");
      div.innerHTML = `<div class="sTitle">${title}</div><div class="sSub">${it.display_name}</div>`;
      div.onclick = () => { el.style.display = "none"; onPick(it); };
      el.appendChild(div);
    });
    el.style.display = "block";
  }

  const searchStart = debounce(async () => {
    const q = startInput.value.trim();
    if (q.length < 3) return showSuggestions(startSug, [], ()=>{});
    try {
      const data = await geocode(q);
      showSuggestions(startSug, data, (it) => {
        startLL = [Number(it.lat), Number(it.lon)];
        startInput.value = it.display_name;
        startMarker = setMarker(startMarker, startLL, "Start", "#111827");
        setPillState("Start set");
      });
    } catch { showSuggestions(startSug, [], ()=>{}); }
  }, 300);

  const searchDest = debounce(async () => {
    const q = destInput.value.trim();
    if (q.length < 3) { destHint.textContent = "Type 3+ chars to see suggestions."; return showSuggestions(destSug, [], ()=>{}); }
    destHint.textContent = "Searching…";
    try {
      const data = await geocode(q);
      destHint.textContent = data.length ? "Tap a suggestion." : "No results.";
      showSuggestions(destSug, data, (it) => {
        destLL = [Number(it.lat), Number(it.lon)];
        destInput.value = it.display_name;
        destMarker = setMarker(destMarker, destLL, "Destination", "#e11d48");
        setPillState("Destination set");
      });
    } catch {
      destHint.textContent = "Search failed.";
      showSuggestions(destSug, [], ()=>{});
    }
  }, 300);

  startInput.addEventListener("input", () => { startLL = null; searchStart(); });
  destInput.addEventListener("input", () => { destLL = null; searchDest(); });

  document.addEventListener("click", (e) => {
    if (!document.getElementById("startField").contains(e.target)) startSug.style.display = "none";
    if (!document.getElementById("destField").contains(e.target))  destSug.style.display = "none";
  });

  // ----- Turn-by-turn helpers -----
  function makeInstruction(step){
    const m = step.maneuver || {};
    const type = (m.type || "").replace(/_/g, " ");
    const mod  = (m.modifier || "").replace(/_/g, " ");
    const name = step.name || "";

    // Simple mapping (MVP but feels good)
    if (m.type === "depart") return "Head out";
    if (m.type === "arrive") return "Arrive at destination";
    if (m.type === "roundabout") return "Enter roundabout" + (step.exit ? `, take exit ${step.exit}` : "");
    if (m.type === "merge") return "Merge" + (name ? ` onto ${name}` : "");
    if (m.type === "on ramp") return "Take the ramp" + (name ? ` onto ${name}` : "");
    if (m.type === "off ramp") return "Take the exit" + (name ? ` to ${name}` : "");
    if (m.type === "fork") return "Keep" + (mod ? ` ${mod}` : "");
    if (m.type === "end of road") return "At end of road, turn" + (mod ? ` ${mod}` : "");
    if (m.type === "continue") return "Continue" + (name ? ` on ${name}` : "");
    if (m.type === "turn") return "Turn" + (mod ? ` ${mod}` : "") + (name ? ` onto ${name}` : "");
    if (m.type === "new name") return "Continue" + (name ? ` on ${name}` : "");
    if (m.type === "rotary") return "Enter rotary" + (step.exit ? `, take exit ${step.exit}` : "");
    if (m.type === "straight") return "Go straight" + (name ? ` on ${name}` : "");

    // fallback
    return (type ? (type[0].toUpperCase()+type.slice(1)) : "Proceed") + (mod ? ` (${mod})` : "") + (name ? ` on ${name}` : "");
  }

  function buildSteps(osrmJson){
    const leg = osrmJson?.routes?.[0]?.legs?.[0];
    const raw = leg?.steps || [];
    const cleaned = raw
      .filter(s => Number.isFinite(s.distance) && s.distance > 1)
      .map((s, idx) => ({
        idx,
        distance: s.distance,
        duration: s.duration,
        name: s.name || "",
        maneuver: s.maneuver || {},
        exit: s.maneuver?.exit,
        instruction: makeInstruction(s),
      }));

    // cumulative distance (for mapping traveled distance -> step index)
    const cum = [];
    let acc = 0;
    for (const s of cleaned) {
      acc += s.distance;
      cum.push(acc);
    }
    steps = cleaned;
    cumStepDist = cum;
  }

  function stepIndexFromTraveled(traveledM){
    // first step where cumulative >= traveled
    for (let i=0;i<cumStepDist.length;i++){
      if (traveledM <= cumStepDist[i]) return i;
    }
    return Math.max(0, cumStepDist.length - 1);
  }

  function stepDistanceRemaining(traveledM, stepIdx){
    const prevCum = stepIdx === 0 ? 0 : cumStepDist[stepIdx - 1];
    const within = traveledM - prevCum; // meters already within this step
    const rem = Math.max(0, steps[stepIdx].distance - within);
    return rem;
  }

  function renderUpcoming(stepIdx){
    const items = steps.slice(stepIdx, stepIdx + 5);
    stepsList.innerHTML = "";
    items.forEach((s, i) => {
      const div = document.createElement("div");
      div.className = "stepRow";
      div.innerHTML = `
        <div class="stepLine1">${i === 0 ? "→ " : ""}${s.instruction}</div>
        <div class="stepLine2">${fmtDist(s.distance)} • ${s.name || "—"}</div>
      `;
      stepsList.appendChild(div);
    });
  }

  function showTurnPanel(show){
    turnCard.style.display = show ? "block" : "none";
  }

  stepsToggle.onclick = () => {
    upcomingOpen = !upcomingOpen;
    stepsList.style.display = upcomingOpen ? "block" : "none";
    stepsChevron.textContent = upcomingOpen ? "▴" : "▾";
  };

  // ----- Routing -----
  async function fetchRoute() {
    if (!destLL) throw new Error("Pick a destination from suggestions.");
    if (!startLL) startLL = await getCurrentPosition();

    const coords = `${startLL[1]},${startLL[0]};${destLL[1]},${destLL[0]}`;
    const url = `${OSRM}${coords}?overview=full&geometries=geojson&steps=true`;

    const res = await fetch(url);
    if (!res.ok) throw new Error("Route HTTP " + res.status);
    const json = await res.json();
    if (!json.routes || !json.routes.length) throw new Error("No route found.");

    const r = json.routes[0];
    routeDurationSec = r.duration;
    routeDistanceM = r.distance;

    routeCoords = r.geometry.coordinates.map(([lon, lat]) => [lat, lon]);

    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(routeCoords, { weight: 6, color: "#2563eb" }).addTo(map);

    startMarker = setMarker(startMarker, startLL, "Start", "#111827");
    destMarker  = setMarker(destMarker, destLL, "Destination", "#e11d48");

    map.fitBounds(routeLine.getBounds(), { padding: [24, 24] });

    pillDist.textContent = "Distance: " + fmtDist(routeDistanceM);
    pillEta.textContent  = "ETA: " + fmtETA(routeDurationSec);
    setPillState("Route ready");
    btnNav.disabled = false;

    // ✅ Build turn-by-turn steps
    buildSteps(json);
    showTurnPanel(true);

    // Default panel content (first step)
    if (steps.length) {
      turnMain.textContent = steps[0].instruction;
      turnDist.textContent = "In " + fmtDist(steps[0].distance);
      turnRoad.textContent = "Road: " + (steps[0].name || "—");
      renderUpcoming(0);
    } else {
      turnMain.textContent = "No steps available";
      turnDist.textContent = "In —";
      turnRoad.textContent = "Road: —";
      stepsList.innerHTML = "";
    }
  }

  function stopNav() {
    if (watchId) navigator.geolocation.clearWatch(watchId);
    watchId = null;
    btnNav.textContent = "Start Navigation";
    setPillState("Navigation stopped");
  }

  function startNav() {
    if (!routeCoords.length) { alert("Create route first."); return; }
    btnNav.textContent = "Stop Navigation";
    setPillState("Navigating…");

    const totalPolylineDist = routeTotalDistance(routeCoords);
    const avgSpeedMps = routeDurationSec ? (totalPolylineDist / routeDurationSec) : 10;

    watchId = navigator.geolocation.watchPosition((pos) => {
      const me = [pos.coords.latitude, pos.coords.longitude];

      userMarker = setMarker(userMarker, me, "You", "#2563eb");
      map.setView(me, Math.max(map.getZoom(), 16), { animate: true });

      const { index, distance } = nearestIndex(me, routeCoords);
      const off = distance > 60;

      const rem = remainingDistance(routeCoords, index);
      pillDist.textContent = "Distance: " + fmtDist(rem);

      const etaSec = avgSpeedMps > 0 ? rem / avgSpeedMps : null;
      pillEta.textContent = "ETA: " + (etaSec ? fmtETA(etaSec) : "—");
      setPillState(off ? "Off route" : "On route", off ? "bad" : "ok");

      // ✅ Turn-by-turn mapping (travelled distance -> step index)
      if (steps.length && routeDistanceM > 0) {
        const traveled = Math.max(0, routeDistanceM - rem);
        const sIdx = stepIndexFromTraveled(traveled);
        const s = steps[sIdx];

        const distToNext = stepDistanceRemaining(traveled, sIdx);

        turnMain.textContent = s.instruction;
        turnDist.textContent = "In " + fmtDist(distToNext);
        turnRoad.textContent = "Road: " + (s.name || "—");
        renderUpcoming(sIdx);
      }

    }, (err) => {
      alert("GPS error: " + err.message);
      stopNav();
    }, { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 });
  }

  // Buttons
  btnUseGPS.onclick = async () => {
    try {
      startLL = await getCurrentPosition();
      startInput.value = "";
      startMarker = setMarker(startMarker, startLL, "Start", "#111827");
      map.setView(startLL, 16, { animate: true });
      setPillState("Using GPS start");
    } catch (e) {
      alert("Location error. Make sure HTTPS and allow permission.");
    }
  };

  btnRoute.onclick = async () => {
    try {
      if (watchId) stopNav();
      btnNav.disabled = true;
      setPillState("Routing…");
      await fetchRoute();
    } catch (e) {
      setPillState("Route failed", "bad");
      alert(e.message || String(e));
    }
  };

  btnNav.onclick = () => { if (watchId) stopNav(); else startNav(); };

  btnClear.onclick = () => {
    if (watchId) stopNav();
    startLL = null; destLL = null;
    startInput.value = ""; destInput.value = "";

    if (startMarker) map.removeLayer(startMarker), startMarker=null;
    if (destMarker) map.removeLayer(destMarker), destMarker=null;
    if (userMarker) map.removeLayer(userMarker), userMarker=null;
    if (routeLine) map.removeLayer(routeLine), routeLine=null;

    routeCoords = [];
    routeDurationSec = 0;
    routeDistanceM = 0;
    steps = [];
    cumStepDist = [];
    stepsList.innerHTML = "";
    showTurnPanel(false);

    pillDist.textContent = "Distance: —";
    pillEta.textContent  = "ETA: —";
    setPillState("Ready");
    btnNav.disabled = true;
  };

  // Service worker (app shell)
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(()=>{});
  }
</script>
</body>
</html>